<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Portada ‚Üí Tulipanes</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{margin:0;height:100%;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
  /* Portada */
  #cover, #app{position:absolute;inset:0;width:100%;height:100%;}
  #cover{
    display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;
    background:linear-gradient(#c9f0ff,#f7fdff);
    padding:24px; box-sizing:border-box;
  }
  #cover h1{font-size:clamp(22px,3.2vw,36px);margin:0 0 12px;color:#104e78}
  #cover p{font-size:clamp(14px,2vw,18px);max-width:700px;margin:0 0 20px;color:#1b3a4b}
  #cover button{
    padding:14px 22px;font-size:18px;border:none;border-radius:10px;cursor:pointer;
    background:#ffb703;color:#fff;box-shadow:0 8px 22px rgba(0,0,0,.15);
  }
  #cover button:hover{background:#fb8500}
  /* App */
  #app{display:none}
  canvas{display:block;width:100vw;height:100vh}
</style>
</head>
<body>

<!-- Portada -->
<div id="cover">
  <h1>üå∑ Hola Pendejita üå∑</h1>
  <p>Si quieres ver tu regalo dale al bot√≥n</p>
  <button id="startBtn">Te amo ‚ù§Ô∏è</button>
</div>

<!-- App -->
<div id="app">
  <canvas id="cv"></canvas>
</div>

<script>
/* -------- Portada: al hacer clic se muestra la app y se inicia -------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  document.getElementById('cover').style.display='none';
  document.getElementById('app').style.display='block';
  init();
  play(); // arranca autom√°ticamente
});

/* -------- Canvas -------- */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');

function fit(){
  const dpr=Math.max(1,window.devicePixelRatio||1);
  cv.width=Math.floor(cv.clientWidth*dpr);
  cv.height=Math.floor(cv.clientHeight*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}

/* -------- Paletas y color -------- */
const Y={BASE:[1,0.85,0],DEEP:[0.8,0.65,0],LIGHT:[1,0.93,0.4],SPEC:[1,1,0.75]};
const G={LIGHT:"#79c36a",DEEP:"#2f7d32"};
const rgbToCss=([r,g,b])=>`rgb(${Math.round((r>1?r/255:r)*255)},${Math.round((g>1?g/255:g)*255)},${Math.round((b>1?b/255:b)*255)})`;
function toHSV([r,g,b]){r=r>1?r/255:r;g=g>1?g/255:g;b=b>1?b/255:b;let max=Math.max(r,g,b),min=Math.min(r,g,b),d=max-min,h=0,s=max?d/max:0,v=max;if(d){switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;default:h=(r-g)/d+4;}h/=6}return{h,s,v};}
function classify(c){const {h,s,v}=toHSV(c||[1,1,0]);const H=h*360;if(s>0.25&&v>0.2){if(H<=35||H>=330||(H>=35&&H<=70))return'petal';if(H>=70&&H<=170)return'leaf';}return'petal';}

/* -------- Fondo celeste uniforme -------- */
function bg(){
  const g = ctx.createLinearGradient(0,0,0,cv.clientHeight);
  g.addColorStop(0,"#c9f0ff"); g.addColorStop(1,"#f7fdff");
  ctx.fillStyle=g; ctx.fillRect(0,0,cv.clientWidth,cv.clientHeight);
}

/* -------- Normalizaci√≥n -------- */
function bounds(S){let minX=1/0,maxX=-1/0,minY=1/0,maxY=-1/0;S.forEach(s=>s.pts.forEach(([x,y])=>{if(x<minX)minX=x;if(x>maxX)maxX=x;if(y<minY)minY=y;if(y>maxY)maxY=y;}));return{minX,maxX,minY,maxY};}
function norm(json){const arr=Array.isArray(json)?json:(json.paths||json.data||[]);return arr.map(o=>({pts:(o.path||o.coords||o.points||[]).map(([x,y])=>[x,y]),color:o.color,cls:o.cls||null})).filter(s=>s.pts.length>2);}
function polyArea(pts){let a=0;for(let i=0,j=pts.length-1;i<pts.length;j=i++){const[xi,yi]=pts[i],[xj,yj]=pts[j];a+=(xj+xi)*(yj-yi);}return Math.abs(a)*0.5;}
function markPanel(shapes){
  if(!shapes.length) return;
  let maxA=-1, idx=-1; shapes.forEach((s,i)=>{const A=polyArea(s.pts); if(A>maxA){maxA=A; idx=i;}});
  if(idx<0) return;
  const {minX,maxX,minY,maxY}=bounds(shapes);
  const cover=polyArea(shapes[idx].pts)/Math.max(1,(maxX-minX)*(maxY-minY));
  const cls = shapes[idx].cls || classify(shapes[idx].color);
  if(cover>0.7 && (cls==='petal' || cls==='other' || !cls)) shapes[idx].cls='panel';
}

/* -------- Rellenos -------- */
function fillPetal(yTop,yBot){
  const g=ctx.createLinearGradient(0,yTop,0,yBot);
  g.addColorStop(0,rgbToCss(Y.SPEC));
  g.addColorStop(0.25,rgbToCss(Y.LIGHT));
  g.addColorStop(0.6,rgbToCss(Y.BASE));
  g.addColorStop(1,rgbToCss(Y.DEEP));
  ctx.fillStyle=g; ctx.fill();
}
function fillLeaf(yTop,yBot){
  const g=ctx.createLinearGradient(0,yTop,0,yBot);
  g.addColorStop(0,G.LIGHT); g.addColorStop(1,G.DEEP);
  ctx.fillStyle=g; ctx.fill();
}
function fillPanel(yTop,yBot){
  const g=ctx.createLinearGradient(0,yTop,0,yBot);
  g.addColorStop(0,"#c9f0ff"); g.addColorStop(1,"#f7fdff");
  ctx.fillStyle=g; ctx.fill();
}

/* -------- Preproceso -------- */
let SHAPES=[], GEO=null, totalLen=0, cumShapeLen=[];
function preprocess(shapes){
  SHAPES = shapes.map(s=>{
    const segs=[]; let len=0;
    for(let i=0;i<s.pts.length;i++){
      const a=s.pts[i], b=s.pts[(i+1)%s.pts.length];
      const L=Math.hypot(b[0]-a[0], b[1]-a[1]); segs.push({a,b,L}); len+=L;
    }
    return {...s, segs, len, cls:(s.cls || classify(s.color))};
  });
  markPanel(SHAPES);
  const bb=bounds(shapes); GEO={bb};
  totalLen = SHAPES.reduce((acc,s)=>acc+s.len,0);
  cumShapeLen=[]; let run=0; for(const s of SHAPES){ cumShapeLen.push(run); run+=s.len; }
}

/* -------- Animaci√≥n -------- */
function drawFrame(progress){
  fit(); bg();
  const {minX,maxX,minY,maxY}=GEO.bb;
  const W=Math.max(1,maxX-minX), H=Math.max(1,maxY-minY);
  const m=40, scale=Math.min((cv.clientWidth-m*2)/W,(cv.clientHeight-m*2)/H);

  ctx.save();
  ctx.translate(cv.clientWidth/2,cv.clientHeight/2);
  ctx.scale(scale,scale);
  ctx.translate(-(minX+maxX)/2, -(minY+maxY)/2);

  const targetLen = totalLen * progress;

  for (let si=0; si<SHAPES.length; si++){
    const s=SHAPES[si];
    const startLen = cumShapeLen[si];
    const endLen   = startLen + s.len;
    if (endLen <= targetLen){
      ctx.beginPath();
      ctx.moveTo(s.pts[0][0], s.pts[0][1]);
      for(let i=1;i<s.pts.length;i++) ctx.lineTo(s.pts[i][0], s.pts[i][1]);
      ctx.closePath();
      let yT=1/0,yB=-1/0; s.pts.forEach(([,y])=>{if(y<yT)yT=y;if(y>yB)yB=y;});
      if (s.cls==='panel'){ fillPanel(yT,yB); continue; }
      if (s.cls==='leaf'){ fillLeaf(yT,yB); }
      else { fillPetal(yT,yB); }
    }
  }
  ctx.restore();
}

/* -------- Loop -------- */
let startTime=0, duration=12000, rafId=null; // duraci√≥n m√°s larga por velocidad 0.5x
function tick(ts){
  if(!startTime) startTime=ts;
  const t = Math.min(1,(ts-startTime)/duration);
  drawFrame(t);
  if (t<1) rafId=requestAnimationFrame(tick);
}
function play(){startTime=0;rafId=requestAnimationFrame(tick);}

/* -------- Cargar JSON -------- */
async function loadJSON(){
  try{
    const r=await fetch('tulipanes.json?v='+Date.now(), {cache:'no-store'});
    if(!r.ok) throw new Error('HTTP '+r.status);
    const json=await r.json();
    const shapes=norm(json);
    if(!shapes.length) throw new Error('JSON vac√≠o');
    preprocess(shapes);
    drawFrame(0);
  }catch(e){console.error('Error cargando JSON', e);}
}

/* -------- Inicializaci√≥n -------- */
function init(){
  fit(); bg();
  loadJSON();
  window.addEventListener('resize', ()=>{fit(); if(SHAPES.length) drawFrame(0);});
}
</script>
</body>
</html>

